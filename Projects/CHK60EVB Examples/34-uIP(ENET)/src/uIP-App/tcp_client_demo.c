#include "tcp_client_demo.h"
#include "uip.h"
#include "string.h"

//本实验所需要的内存定义
uint8_t tcp_client_rec_buf[64];
uint8_t tcp_client_send_buf[64];   	//发送数据缓存	  
uint8_t tcp_client_sta;				//客户端状态
uint8_t tcp_client_rec_len;               //接收到的数据长度
//函数声明
void tcp_client_reconnect(void);
void tcp_client_aborted(void);
void tcp_client_timedout(void);
void tcp_client_closed(void);
void tcp_client_connected(void);
void tcp_client_acked(void);
void tcp_client_senddata(void);
//这是一个TCP 客户端应用回调函数。
//该函数通过UIP_APPCALL(tcp_demo_appcall)调用,实现Web Client的功能.
//当uip事件发生时，UIP_APPCALL函数会被调用,根据所属端口(1400),确定是否执行该函数。
//例如 : 当一个TCP连接被创建时、有新的数据到达、数据已经被应答、数据需要重发等事件
void tcp_client_demo_appcall(void)
{
 	struct tcp_demo_appstate *s = (struct tcp_demo_appstate *)&uip_conn->appstate;
	if(uip_aborted())
	{
		tcp_client_aborted();		//连接终止	 
	}
	if(uip_timedout())
	{
		tcp_client_timedout();	//连接超时   
	}
	if(uip_closed())
	{
		tcp_client_closed();		//连接关闭	
	}
 	if(uip_connected())
	{
		tcp_client_connected();	//连接成功
	}    
	if(uip_acked())
	{
		tcp_client_acked();			//发送的数据成功送达  
	}
 	//接收到一个新的TCP数据包 
	if (uip_newdata())
	{
		if((tcp_client_sta&(1<<6))==0)//还未收到数据
		{
			if(uip_len>199)
			{		   
				((uint8_t*)uip_appdata)[199]=0;
			}		    
			if(uip_len>64) tcp_client_rec_len = 64; else tcp_client_rec_len = uip_len;
	    memcpy(tcp_client_rec_buf,uip_appdata,tcp_client_rec_len);			   	  		  
			tcp_client_sta|=1<<6;//表示收到客户端数据
		}				  
	}else if(tcp_client_sta&(1<<5))//有数据需要发送
	{
		s->textptr=tcp_client_send_buf;
		s->textlen=strlen((const char*)tcp_client_send_buf);
		tcp_client_sta&=~(1<<5);//清除标记
	}  
	//当需要重发、新数据到达、数据包送达、连接建立时，通知uip发送数据 
	if(uip_rexmit()||uip_newdata()||uip_acked()||uip_connected()||uip_poll())
	{
		tcp_client_senddata();
	}			
}

//这里我们假定Server端的IP地址为:192.168.0.1
//这个IP必须根据Server端的IP修改.
//尝试重新连接
void tcp_client_reconnect()
{
	uip_ipaddr_t ipaddr;
	uip_ipaddr(&ipaddr,192,168,0,2);	//设置PC机 IP为192.168.0.2
	uip_connect(&ipaddr,htons(1400)); 	//端口为1400
}
//终止连接				    
void tcp_client_aborted(void)
{
	tcp_client_sta&=~(1<<7);	//标志没有连接
	tcp_client_reconnect();		//尝试重新连接
	uip_log("tcp_client aborted!\r\n");//打印log
}
//连接超时
void tcp_client_timedout(void)
{
	tcp_client_sta&=~(1<<7);	//标志没有连接	   
	uip_log("tcp_client timeout!\r\n");//打印log
}
//连接关闭
void tcp_client_closed(void)
{
	tcp_client_sta&=~(1<<7);	//标志没有连接
	tcp_client_reconnect();		//尝试重新连接
	uip_log("tcp_client closed!\r\n");//打印log
}	 
//连接建立
void tcp_client_connected(void)
{ 
	struct tcp_demo_appstate *s=(struct tcp_demo_appstate *)&uip_conn->appstate;
 	tcp_client_sta|=1<<7;		//标志连接成功
  	uip_log("tcp_client connected!\r\n");//打印log
	s->state=STATE_CMD; 		//指令状态
	s->textlen=0;
	s->textptr="已成功连接超核K60 开发板 \r\n";//回应消息
	s->textlen=strlen((char *)s->textptr);	  
}
//发送的数据成功送达
void tcp_client_acked(void)
{											    
	struct tcp_demo_appstate *s=(struct tcp_demo_appstate *)&uip_conn->appstate;
	s->textlen=0;//发送清零
	uip_log("tcp_client acked!\r\n");//表示成功发送		 
}
//发送数据给服务端
void tcp_client_senddata(void)
{
	struct tcp_demo_appstate *s = (struct tcp_demo_appstate *)&uip_conn->appstate;
	//s->textptr:发送的数据包缓冲区指针
	//s->textlen:数据包的大小（单位字节）		   
	if(s->textlen>0)uip_send(s->textptr, s->textlen);//发送TCP数据包	 
}
//用户接口 TCP client 发送数据
uint8_t app_tcp_client_senddata(uint8_t* data,uint16_t len)
{
	if(len > sizeof(tcp_client_send_buf)) //太大
	{
		return 2;
	}
	if(tcp_client_sta&(1<<7))	//连接还存在
	{
	  memcpy(tcp_client_send_buf,data,len);
		tcp_client_sta|=1<<5;//标记有数据需要发送
		return 0;//发送成功 
	}
	else return 1;//发送失败
}
//用户接口 TCP 服务器 接收数据
uint16_t app_tcp_client_recdata(uint8_t* data)
{
	if(tcp_client_sta&(1<<6))	//收到新数据
	{
		memcpy(data,tcp_client_rec_buf,tcp_client_rec_len);
		tcp_client_sta&=~(1<<6);		//标记数据已经被处理	
		return tcp_client_rec_len;
	}
	return 0;
}
